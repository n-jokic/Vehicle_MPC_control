home_directory = string(java.lang.System.getProperty("user.home"));
casadi_folder = 'casadi-3.6.4-windows64-matlab2018b';
casad_path = fullfile(home_directory, casadi_folder);
addpath(casad_path);

%% Model setup:
%          model parameters:    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

g = 9.81; % gravitational acceleration
m = 1900; % [kg]
a = 1.05; % distance from CM to front tyres
b = 1.8-a; % distance from CM to back tyres
I = m*a*b; % car inertia
c = 1.5; % width of wheel axels
friction = 0.9; %friction coeff

r = 0.3284; % diameter of a wheel 
Idf = 0.805; % Inertia of front tyres
Idr = 0.805; % Inerita of rear tyres
Bd = 0.1; % tyre angular speed damping factor

Fzf = b*m*g/2/(a+b)/1000; % [kN] force on front tyres
Fzr = a*m*g/2/(a+b)/1000; % [kN] force on rear tyres



%          model states:        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ydot = casadi.SX.sym('ydot');
xdot = casadi.SX.sym('xdot');

psi = casadi.SX.sym('psi');
psidot = casadi.SX.sym('psidot');

Y = casadi.SX.sym('Y');
X = casadi.SX.sym('X');

wfl = casadi.SX.sym('wfl');
wfr = casadi.SX.sym('wfr');
wrl = casadi.SX.sym('wrl');
wrr = casadi.SX.sym('wrr');

%          state vector:        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
states = [ydot; xdot;
     psi; psidot;
     Y; X;
     wfl; wfr; wrl; wrr
     ];

%          control states:      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
deltaf = casadi.SX.sym('deltaf');

Tbfl = casadi.SX.sym('Tbfl');
Tbfr = casadi.SX.sym('Tbfr');
Tbrl = casadi.SX.sym('Tbrl');
Tbrr = casadi.SX.sym('Tbrr');

%          control vector:      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
control = [deltaf;
     Tbfl; Tbfr; Tbrl; Tbrr
     ];

%       auxiliary states:       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
w = casadi.SX.sym('w');
T = casadi.SX.sym('T');
s = casadi.SX.sym('s');
vx = casadi.SX.sym('vx');
vy = casadi.SX.sym('vy');
delta = casadi.SX.sym('delta');
angle = casadi.SX.sym('angle');
mu = casadi.SX.sym('mu');
Fx = casadi.SX.sym('Fx');
Fy = casadi.SX.sym('Fy');
slip_vector = casadi.SX.sym('slip_vector', 4); 
alpha_vector = casadi.SX.sym('alpha_vector', 4); 
forces = casadi.SX.sym('forces', 12);
delta_front = casadi.SX.sym('delta_front');
delta_rear = casadi.SX.sym('delta_rear');
vl_vct = casadi.SX.sym('vl_vct', 4); 
vc_vct = casadi.SX.sym('vc_vct', 4); 
vl_vc = casadi.SX.sym('vl_vc_vct', 8);

%  wheel speeds calculation:    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
vyfl = casadi.Function('vyfl', {ydot, psidot}, ...
                        {ydot + a*psidot} ...
                        ,{'ydot', 'psidot'}, {'vyfl'});
vxfl = casadi.Function('vxfl', {xdot, psidot}, ...
                        {xdot - c*psidot} ...
                        ,{'xdot', 'psidot'}, {'vxfl'});

vyfr = casadi.Function('vyfr', {ydot, psidot}, ...
                        {ydot + a*psidot} ...
                        ,{'ydot', 'psidot'}, {'vyfr'});
vxfr = casadi.Function('vxfr', {xdot, psidot}, ...
                        {xdot + c*psidot} ...
                        ,{'xdot', 'psidot'}, {'vxfr'});

vyrl = casadi.Function('vyrl', {ydot, psidot}, ...
                        {ydot - b*psidot} ...
                        ,{'ydot', 'psidot'}, {'vyrl'});
vxrl = casadi.Function('vxrl', {xdot, psidot}, ...
                        {xdot - c*psidot} ...
                        ,{'xdot', 'psidot'}, {'vxrl'});

vyrr = casadi.Function('vyrr', {ydot, psidot}, ...
                        {ydot - b*psidot} ...
                        ,{'ydot', 'psidot'}, {'vyrr'});
vxrr = casadi.Function('vxfl', {xdot, psidot}, ...
                        {xdot + c*psidot} ...
                        ,{'xdot', 'psidot'}, {'vxrr'});

v_vctr = casadi.Function('v_vctr', {ydot, xdot, psidot}, ...
                        {[ ...
                        vxfl(xdot, psidot); ...
                        vyfl(ydot, psidot); ...
                        vxfr(xdot, psidot); ...
                        vyfr(ydot, psidot); ...
                        vxrl(xdot, psidot); ...
                        vyrl(ydot, psidot); ...
                        vxrr(xdot, psidot); ...
                        vyrr(ydot, psidot); ...
                        ]} ...
                        ,{'ydot', 'xdot', 'psidot'}, {'v_vctr'});
% longitudal/normal conversion: %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

mixing_matrix = casadi.Function('mixing_matrix', ...
    {delta_front, delta_rear}, ...
    {[[ cos(delta_front), sin(delta_front), 0, 0, 0, 0, 0, 0]; ...
      [-sin(delta_front), cos(delta_front), 0, 0, 0, 0, 0, 0];...
      [ 0, 0, cos(delta_front), sin(delta_front), 0, 0, 0, 0]; ...
      [ 0, 0,-sin(delta_front), cos(delta_front), 0, 0, 0, 0];...
      [ 0, 0, 0, 0, cos(delta_rear), sin(delta_rear), 0, 0]; ...
      [ 0, 0, 0, 0,-sin(delta_rear), cos(delta_rear), 0, 0];...
      [ 0, 0, 0, 0, 0, 0, cos(delta_rear), sin(delta_rear)]; ...
      [ 0, 0, 0, 0, 0, 0,-sin(delta_rear), cos(delta_rear)];...
    ] ...
    }, {'delta_front', 'delta_rear'}, {'mixing_matrix'});

vl_vc_vctr = casadi.Function('vl_vc_vctr', ...
    {ydot, xdot, psidot, delta_front, delta_rear}, ...
    {mixing_matrix(delta_front, delta_rear)*v_vctr(ydot, xdot, psidot)}...
    , {'ydot', 'xdot', 'psidot', 'delta_front', 'delta_rear'}, ...
    {'vl_vc_vctr'});

%  slip and alpha calculation:  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

slip_driving = casadi.Function('slip_driving', {vx, w}, ...
    {if_else(w==0, ...
             if_else(vx==0, ...
                     1-1/r, ...
                     -sign(vx) ...
                     ), ...
             1-vx/w/r ...
            ) ...
    } ...
    , {'vl', 'w'}, {'s'});

slip_braking = casadi.Function('slip_braking', {vx, w}, ...
    {if_else(vx==0, ...
             if_else(w==0, ...
                     r-1, ...
                     sign(w) ...
                     ), ...
             r*w/vx - 1 ...
            ) ...
    } ...
    , {'vl', 'w'}, {'s'});

clip = casadi.Function('s', {s}, ...
                       {if_else(s>1, ...
                                1, ...
                                if_else(s<-1, ...
                                        -1, ...
                                        s))}...
                      , {'s'}, {'s_clip'});

slip = casadi.Function('slip', {vx, w, T}, ...
    {if_else(T > 0, ...
             100*clip(slip_braking(vx, w)), ...
             100*clip(slip_driving(vx, w)) ...
            ) ...
    } ...
    , {'vl', 'w', 'T'}, {'s'});


alpha = casadi.Function('alpha', {vy, vx}, ...
                        {atan2(vx, ...
                               vy)/pi*180}...
                        , {'vc', 'vl'}, {'alpha'});

alpha_approx = casadi.Function('alpha', {vy, vx, delta, psi}, ...
                        {-delta/180*pi - psi + vy/vx}...
                        , {'vc', 'vl', 'delta', 'psi'}, {'alpha'});


%      Pajaceka Tyre model:     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
C = b0;
D = (b1*Fzf^2 + b2*Fzf);
B = (b3*Fzf^2 + b4*Fzf)/(C*D)*exp(-b5*Fzf);
E = b6*Fzf^2 + b7*Fzf + b8;

Fl0 = casadi.Function('Fl0', {s, mu}, ...
                       {mu*D*sin(C*atan(B*(1-E)*s + E*atan(B*s)))} ...
                       , {'s', 'mu'}, {'Fl0'});

C = a0;
D = (a1*Fzr^2 + a2*Fzr);
B = (a3*sin(a4*atan(Fzr/a5)))/C/D;
E = a6*Fzr^2 + a7*Fzr + a8;
Sh = 0;
Sv = 0;

Fc0 = casadi.Function('Fc0', {angle, mu}, ...
                       {-mu*D*sin(C*atan(B*(1-E)*(angle+Sh) + ...
                       E*atan(B*(angle+Sh)))) + Sv} ...
                       , {'alpha', 'mu'}, {'Fc0'});

beta = casadi.Function('beta', {angle, s}, ...
                        {atan2(sin(angle/180*pi), s/100)} ...
                        ,{'alpha', 's'}, {'beta'});

Fl_Fc = casadi.Function('Fl_Fc', {Fx, Fy, angle}, ...
                        {[Fx*abs(cos(angle)); ...
                          Fy*abs(sin(angle)) ...
                          ]} ...
                          , {'Fl', 'Fc', 'beta'}...
                          , {'Fl_Fc_vector'}...
                          );

Fx_Fy = casadi.Function('Fx_Fy', {delta, angle, s, mu}, ...
                         {[[cos(delta), -sin(delta)]; ...
                           [sin(delta), +cos(delta) ...
                           ]]*Fl_Fc(Fl0(s, mu), ...
                                Fc0(angle, mu), ...
                                beta(angle, s) ...
                                ) ...
                          } ...
                          , {'delta', 'alpha', 's', 'mu'}...
                          , {'Fx_Fy_vector'}...
                          );


%          model equations:     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

state_transition_force = casadi.Function('f_force', ...
    {states, control, forces}, ...
    {[ -states(2)*states(4) + sum(forces(2:2:end-4))/m;...
       states(1)*states(4) + sum(forces(1:2:end-4))/m;...
       states(4);
       1/I*(a*(forces(2)+forces(4)) ...
           - b*(forces(6)+forces(8)) ...
           +c*(-forces(1)+forces(3)-forces(5)+forces(7)) ...
           ); ...
       states(2)*sin(states(3)) + states(1)*cos(states(3));...
       states(2)*cos(states(3)) - states(1)*sin(states(3));...
       1/Idf*(-forces(end-3)*r-control(2)-Bd*states(7));...
       1/Idf*(-forces(end-2)*r-control(3)-Bd*states(8));...
       1/Idr*(-forces(end-1)*r-control(4)-Bd*states(9));...
       1/Idr*(-forces(end)*r-control(5)-Bd*states(10));...
    ] ...
    } ...
    , {'states', 'control', 'forces'}, {'dot_states_force_wrapper'});

state_transition_slip_alpha = casadi.Function('f_slip_alpha', ...
    {states, control, slip_vector, alpha_vector}, ...
    {state_transition_force(states, control, ...
    [Fx_Fy(control(1), alpha_vector(1), slip_vector(1), friction); ...
     Fx_Fy(control(1), alpha_vector(2), slip_vector(2), friction); ...
     Fx_Fy(0, alpha_vector(3), slip_vector(3), friction); ...
     Fx_Fy(0, alpha_vector(4), slip_vector(4), friction); ...
     [1, 0]*Fl_Fc(Fl0(slip_vector(1), friction),... 
                  Fc0(alpha_vector(1), friction), ...
                  beta(alpha_vector(1), slip_vector(1)) ...
                  ); ...
     [1, 0]*Fl_Fc(Fl0(slip_vector(2), friction),... 
                  Fc0(alpha_vector(2), friction), ...
                  beta(alpha_vector(2), slip_vector(2)) ...
                  ); ...
     [1, 0]*Fl_Fc(Fl0(slip_vector(3), friction),... 
                  Fc0(alpha_vector(3), friction), ...
                  beta(alpha_vector(3), slip_vector(3)) ...
                  ); ...
     [1, 0]*Fl_Fc(Fl0(slip_vector(4), friction),... 
                  Fc0(alpha_vector(4), friction), ...
                  beta(alpha_vector(4), slip_vector(4)) ...
                  ) ...
    ] ...
    ) ...
    } ...
    , {'states', 'control', 'slip_vector', 'alpha_vector'}, ...
    {'dot_states_alpha_slip_wrapper'});


state_transition_speed = casadi.Function('f_speed', ...
    {states, control, vl_vc, slip_vector},...
    {state_transition_slip_alpha(states, control, ...
    slip_vector, ...
    alpha(vl_vc(2:2:end), vl_vc(1:2:end))...
    )...
    }...
    , {'states', 'control', 'vl_vc_vector', 'slip_vector'},...
    {'dot_states_speed_wrapper'}...
    );

state_transition = casadi.Function('f', ...
    {states, control, slip_vector},...
    {state_transition_speed(states, control, ...
    vl_vc_vctr(ydot, xdot, psidot, control(1)/180*pi, 0)...
    , slip_vector...
    )...
    }...
    , {'states', 'control', 'slip_vector'},...
    {'dot_states'}...
    );


state_transition_speed_approx = casadi.Function('f_speed', ...
    {states, control, vl_vc, slip_vector},...
    {state_transition_slip_alpha(states, control, ...
    slip_vector, ...
    alpha_approx(vl_vc(2:2:end), vl_vc(1:2:end), [control(1); control(1); 0; 0], control(3))...
    )...
    }...
    , {'states', 'control', 'vl_vc_vector', 'slip_vector'},...
    {'dot_states_speed_wrapper'}...
    );

state_transition_approx = casadi.Function('f', ...
    {states, control, slip_vector},...
    {state_transition_speed(states, control, ...
    v_vctr(ydot, xdot, psidot)...
    , slip_vector...
    )...
    }...
    , {'states', 'control', 'slip_vector'},...
    {'dot_states'}...
    );

%% MPC setup:
h = 0.05; %step size in seconds [s]
N = 5; % prediction horizon
Nc = 2;
iter_num = casadi.SX.sym('iter_num');
reference = casadi.SX.sym('reference', 4, 1);

n_controls = length(control);
state_transition; %nonlinear mapping (state_t, control_t)->state_t+1
n_states = length(states);
n_ref = 4; % number of reference signals
n_slip = 4;

% weighing matrix (states)
Q = zeros(n_ref,n_ref); 
Q(1,1) = 1;Q(2,2) = 5;Q(3,3) = 0.1; Q(4,4)=1;

% weighing matrix (controls)
R = zeros(n_controls,n_controls); 
R(1,1) = 0.5; R(2,2) = 0.05; R(3,3) = 0.05; R(4,4) = 0.05; R(5,5) = 0.05;

ref_states = zeros(n_ref, n_states);
ref_states(1, 2) = 1; ref_states(2, 3) = 1; 
ref_states(3, 4) = 1; ref_states(4, 5) = 1; 

J = (ref_states*states-reference)'*Q*(ref_states*states-reference) ...
            + control'*R*control*(iter_num<=Nc);

% Continuous time dynamics
f = casadi.Function('f', {states, control, reference, ...
    slip_vector, iter_num}, ...
    {state_transition(states, control, slip_vector), J});

% Formulate discrete time dynamics
% Fixed step Runge-Kutta 4 integrator
M = 1; % RK4 steps per interval
DT = h/N/M;
X0 = casadi.MX.sym('X0', n_states);
U = casadi.MX.sym('U', n_controls);
Slip = casadi.MX.sym('Slip', 4);
Iter  = casadi.MX.sym('Iter_num');
Ref = casadi.MX.sym('Ref', 4);
X = X0;
Q = 0;
for j=1:M
   %[k1, k1_q] = f(X, U, Ref, Slip, Iter);
   %[k2, k2_q] = f(X + DT/2 * k1, U, Ref, Slip, Iter);
   %[k3, k3_q] = f(X + DT/2 * k2, U, Ref, Slip, Iter);
   %[k4, k4_q] = f(X + DT * k3, U, Ref, Slip, Iter);
   %X=X+DT/6*(k1 +2*k2 +2*k3 +k4);
   %Q = Q + DT/6*(k1_q + 2*k2_q + 2*k3_q + k4_q);

   sol = f(X, U, Ref, Slip, Iter);
   X = X + h*sol(1);
   Q = Q + h*sol(2);
    % g = [g;st_next-st_next_euler]; % compute constraints
end
F = casadi.Function('F', {X0, U, Ref, Slip, Iter}, ...
    {X, Q}, {'x0', 'u', 'reference', 'slip_vector', 'iter_num'}, ...
    {'xf', 'qf'});



% Decision variables (controls)
U = casadi.MX.sym('U',n_controls,N); 

% parameters (which include the initial state and the reference state)
P = casadi.MX.sym('P',n_ref + n_states+n_slip);

% A vector that represents the states over the optimization problem.
X = casadi.MX.sym('X',n_states,(N+1));


obj = 0; % Objective function
g = [];  % constraints vector


st  = X(:,1); % initial state
g = [g;st-P(n_ref+1:n_ref+n_states)]; % initial condition constraints
slip = casadi.MX(P(n_ref+n_states+1:end));
ref = casadi.MX(P(1:n_ref));


for k = 1:N
    st = casadi.MX(X(:,k));  con =  casadi.MX(U(:,k));    
    Xk =  casadi.MX(X(:,k+1));
   
    Fk = F('x0', st, 'u', con, ...
        'reference', ref,  'slip_vector', slip, 'iter_num',k);
    Xk_end = Fk.xf;
    obj = Fk.qf;

    
    g = [g; Xk-Xk_end];

    if k~= N && k>Nc -1
        Uk = U(:,k+1);
        g = [g; Uk-U(:, Nc)];
    end
end

% make the decision variable one column  vector
OPT_variables = [reshape(X,(N+1)*n_states,1);reshape(U,(N)*n_controls,1)];

nlp_prob = struct('f', obj, 'x', OPT_variables, 'g', g, 'p', P);

% solver setup:
opts = struct;
opts.ipopt.max_iter = 2000;
opts.ipopt.print_level =0;%0,3
opts.print_time = 0;
opts.ipopt.acceptable_tol =1e-8;
opts.ipopt.acceptable_obj_change_tol = 1e-6;

solver = casadi.nlpsol('solver', 'ipopt', nlp_prob, opts);


args = struct;

args.lbg(1:n_states*(N+1)+n_controls*(N-Nc)) = 1e-20;  % Equality constraints
args.ubg(1:n_states*(N+1)+n_controls*(N-Nc)) = 1e-20;   % Equality constraints

for i = 1 : n_states

    args.lbx(i:n_states:n_states*(N+1),1) = -2; %state x lower bound
    args.ubx(i:n_states:n_states*(N+1),1) = 2; %state x upper bound
end

for i = 1 : n_controls
    args.lbx(n_states*(N+1)+i:n_controls:n_states*(N+1)+n_controls*(N),1) = -5; %v lower bound
    args.ubx(n_states*(N+1)+i:n_controls:n_states*(N+1)+n_controls*(N),1) = 5; %v upper bound
end


slip_measurement = casadi.MX.sym('slip_measurement', 4);
reference_trajecotry = casadi.MX.sym('reference_trajecotry', 4);
state_measurement = casadi.MX.sym('state_measurement', n_states);
control_measurement = casadi.MX.sym('control_measurement', n_controls);

args.p = [slip_measurement; reference_trajecotry; state_measurement];
args.x0  = [];
for i = 1 : N+1
    args.x0 = [args.x0; state_measurement];
end
for i = 1 : N
    args.x0 = [args.x0; control_measurement];
end


ubw_sym = casadi.MX(args.ubx);
lbw_sym = casadi.MX(args.lbx);

lbw_sym(1:n_states) = state_measurement;
ubw_sym(1:n_states) = state_measurement;

sol_sym = solver('x0', args.x0, 'lbx', lbw_sym, 'ubx', ubw_sym,...
            'lbg', args.lbg, 'ubg', args.ubg);


function_name = 'mpc';
mpc = casadi.Function(function_name,{state_measurement, control_measurement ...
    reference_trajecotry, slip_measurement ...
    },{sol_sym.x(n_states*(N+1)+1:(N+1)*n_states+n_controls)});

%%

tic
u = mpc(ones(10, 1), zeros(5,1), ones(4,1)*0.1, zeros(4,1));
toc



